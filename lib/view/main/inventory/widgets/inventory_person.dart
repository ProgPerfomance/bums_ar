import 'package:flutter/material.dart';/// Типы слотов экипировкиenum EquipmentSlot {  hands,     // Руки (оружие)  boots,     // Обувь  head,      // Голова  mask,      // Маска  tshirt,    // Футболка  jacket,    // Куртка  pants,     // Штаны  watch,     // Часы  backpack,  // Рюкзак  gloves,    // Перчатки  vest,      // Бронежилет}/// Модель предметаclass EquipmentItem {  final String name;  final String? imageUrl;  const EquipmentItem({required this.name, this.imageUrl});}/// Действие контекстного менюclass EquipMenuAction {  final String text;  final IconData icon;  final bool enabled;  final VoidCallback onTap;  const EquipMenuAction({    required this.text,    required this.icon,    required this.onTap,    this.enabled = true,  });}/// Билдер действий для слотаtypedef EquipMenuBuilder = List<EquipMenuAction> Function(    EquipmentSlot slot,    EquipmentItem? equipped,    );/// Главный виджет экипировки: 4 слева, 4 справа, 3 снизу. Сверху — пусто.class EquipmentView extends StatelessWidget {  final Map<EquipmentSlot, EquipmentItem?> equipped;  final EquipMenuBuilder? menuBuilder;  /// Базовый размер слота (компактный)  final double slotSize;  /// Базовый коэффициент ширины аватара от меньшей стороны  final double baseAvatarFactor;  const EquipmentView({    super.key,    required this.equipped,    this.menuBuilder,    this.slotSize = 64,       // компактнее, чтобы не лезло    this.baseAvatarFactor = 0.58, // будет авто-урезан под нижний ряд  });  @override  Widget build(BuildContext context) {    // Фиксированные группы слотов    final leftSlots = <EquipmentSlot>[      EquipmentSlot.head,      EquipmentSlot.mask,      EquipmentSlot.tshirt,      EquipmentSlot.jacket,    ];    final rightSlots = <EquipmentSlot>[      EquipmentSlot.vest,      EquipmentSlot.gloves,      EquipmentSlot.hands,      EquipmentSlot.watch,    ];    final bottomSlots = <EquipmentSlot>[      EquipmentSlot.pants,      EquipmentSlot.boots,      EquipmentSlot.backpack,    ];    return LayoutBuilder(      builder: (context, c) {        final w = c.maxWidth;        final h = c.maxHeight;        // --- Геометрия нижнего ряда ---        final bottomRowHeight = slotSize; // ровно под нижние 3        final availableHeightForColumns = h - bottomRowHeight; // чтобы боковые не заезжали на низ        // --- Размер центрального аватара ---        final minSide = w < h ? w : h;        double avatarWidth = (minSide * baseAvatarFactor).clamp(220.0, 500.0);        double avatarHeight = avatarWidth * 1.25;        // Если аватар выпирает в зону нижних слотов — уменьшаем его        final mustLeaveBottom = bottomRowHeight + 8; // 8px минимальный зазор        final maxAvatarHalfHeight = (h / 2) - mustLeaveBottom;        if (avatarHeight / 2 > maxAvatarHalfHeight) {          final scale = (maxAvatarHalfHeight * 2) / avatarHeight;          if (scale.isFinite && scale > 0) {            avatarWidth *= scale;            avatarHeight *= scale;          }        }        // --- Вертикальная раскладка боковых слотов ---        const gap = 8.0; // компактный вертикальный зазор        final leftCount = leftSlots.length;  // 4        final rightCount = rightSlots.length; // 4        double columnBlockHeight(int count) =>            count * slotSize + (count - 1) * gap;        final leftBlockH = columnBlockHeight(leftCount);        final rightBlockH = columnBlockHeight(rightCount);        // Центрируем блоки по вертикали в доступной высоте (без нижнего ряда)        final leftTop = ((availableHeightForColumns - leftBlockH) / 2).clamp(0.0, availableHeightForColumns - leftBlockH);        final rightTop = ((availableHeightForColumns - rightBlockH) / 2).clamp(0.0, availableHeightForColumns - rightBlockH);        return Stack(          children: [            // Центр: аватар            Positioned(              left: (w - avatarWidth) / 2,              top: (availableHeightForColumns - avatarHeight) / 2, // центрируем в доступной высоте              width: avatarWidth,              height: avatarHeight,              child: const _AvatarPlaceholder(),            ),            // ЛЕВАЯ колонка (4 слота), прижата к левому краю, ровные промежутки            for (int i = 0; i < leftCount; i++)              Positioned(                left: 0,                top: leftTop + i * (slotSize + gap),                width: slotSize,                height: slotSize,                child: _SlotChip(                  slot: leftSlots[i],                  item: equipped[leftSlots[i]],                  size: slotSize,                  menuBuilder: menuBuilder,                ),              ),            // ПРАВАЯ колонка (4 слота), прижата к правому краю            for (int i = 0; i < rightCount; i++)              Positioned(                right: 0,                top: rightTop + i * (slotSize + gap),                width: slotSize,                height: slotSize,                child: _SlotChip(                  slot: rightSlots[i],                  item: equipped[rightSlots[i]],                  size: slotSize,                  menuBuilder: menuBuilder,                ),              ),            // НИЖНИЙ ряд (3 слота), строго у нижнего края, равномерно по ширине            Positioned(              left: 0,              right: 0,              bottom: 0,              height: bottomRowHeight,              child: Row(                mainAxisAlignment: MainAxisAlignment.spaceEvenly,                children: bottomSlots                    .map(                      (s) => SizedBox(                    width: slotSize,                    height: slotSize,                    child: _SlotChip(                      slot: s,                      item: equipped[s],                      size: slotSize,                      menuBuilder: menuBuilder,                    ),                  ),                )                    .toList(),              ),            ),          ],        );      },    );  }}/// Заглушка «бомж»class _AvatarPlaceholder extends StatelessWidget {  const _AvatarPlaceholder();  @override  Widget build(BuildContext context) {    return DecoratedBox(      decoration: BoxDecoration(        color: const Color(0xFF2A2F36),        borderRadius: BorderRadius.circular(16),        border: Border.all(color: Colors.white12, width: 2),        gradient: const LinearGradient(          begin: Alignment.topCenter,          end: Alignment.bottomCenter,          colors: [Color(0xFF323842), Color(0xFF1B2027)],        ),      ),      child: const Center(        child: Text(          'БОМЖ',          style: TextStyle(            color: Colors.white38,            fontWeight: FontWeight.w700,            letterSpacing: 2,          ),        ),      ),    );  }}/// Тайлик слота (компактный)class _SlotChip extends StatefulWidget {  final EquipmentSlot slot;  final EquipmentItem? item;  final double size;  final EquipMenuBuilder? menuBuilder;  const _SlotChip({    required this.slot,    required this.item,    required this.size,    required this.menuBuilder,  });  @override  State<_SlotChip> createState() => _SlotChipState();}class _SlotChipState extends State<_SlotChip> {  final GlobalKey _key = GlobalKey();  @override  Widget build(BuildContext context) {    final label = _slotLabel(widget.slot);    final icon = _slotIcon(widget.slot);    return GestureDetector(      key: _key,      onTapDown: (_) async {        if (widget.menuBuilder == null) return;        final actions = widget.menuBuilder!.call(widget.slot, widget.item);        if (actions.isEmpty) return;        final ctx = _key.currentContext;        if (ctx == null) return;        final box = ctx.findRenderObject() as RenderBox?;        if (box == null) return;        final offset = box.localToGlobal(Offset.zero);        final rect = offset & box.size;        final selected = await showMenu<int>(          context: context,          position: RelativeRect.fromLTRB(            rect.left,            rect.bottom,            rect.right,            rect.top,          ),          items: List.generate(actions.length, (i) {            final a = actions[i];            return PopupMenuItem<int>(              value: i,              enabled: a.enabled,              child: Row(                mainAxisSize: MainAxisSize.min,                children: [                  Icon(a.icon, size: 18),                  const SizedBox(width: 8),                  Expanded(child: Text(a.text)),                ],              ),            );          }),        );        if (selected != null) {          actions[selected].onTap();        }      },      child: Container(        width: widget.size,        height: widget.size,        decoration: BoxDecoration(          color: const Color(0xFF1A1F26),          borderRadius: BorderRadius.circular(12),          border: Border.all(color: Colors.white24, width: 1.6),        ),        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: [            // Иконка или чек, если надето            Icon(              widget.item == null ? icon : Icons.check_circle,              color: Colors.white70,              size: widget.size * 0.34,            ),            const SizedBox(height: 3),            Text(              widget.item?.name ?? label,              maxLines: 1,              overflow: TextOverflow.ellipsis,              style: const TextStyle(                color: Colors.white70,                fontSize: 10,                fontWeight: FontWeight.w600,              ),            ),          ],        ),      ),    );  }}/// ПодписиString _slotLabel(EquipmentSlot s) {  switch (s) {    case EquipmentSlot.hands:      return 'Руки';    case EquipmentSlot.boots:      return 'Обувь';    case EquipmentSlot.head:      return 'Голова';    case EquipmentSlot.mask:      return 'Маска';    case EquipmentSlot.tshirt:      return 'Футболка';    case EquipmentSlot.jacket:      return 'Куртка';    case EquipmentSlot.pants:      return 'Штаны';    case EquipmentSlot.watch:      return 'Часы';    case EquipmentSlot.backpack:      return 'Рюкзак';    case EquipmentSlot.gloves:      return 'Перчатки';    case EquipmentSlot.vest:      return 'Броня';  }}/// Иконки-заглушкиIconData _slotIcon(EquipmentSlot s) {  switch (s) {    case EquipmentSlot.hands:      return Icons.sports_kabaddi;    case EquipmentSlot.boots:      return Icons.hiking;    case EquipmentSlot.head:      return Icons.emoji_people;    case EquipmentSlot.mask:      return Icons.masks;    case EquipmentSlot.tshirt:      return Icons.checkroom;    case EquipmentSlot.jacket:      return Icons.style;    case EquipmentSlot.pants:      return Icons.travel_explore;    case EquipmentSlot.watch:      return Icons.watch_later;    case EquipmentSlot.backpack:      return Icons.backpack;    case EquipmentSlot.gloves:      return Icons.pan_tool_alt;    case EquipmentSlot.vest:      return Icons.shield;  }}